<body>
  <h1>Vocab Check</h1>

  <div id="app">
    <label>
      학생 ID
      <input id="studentIdInput" placeholder="예: khh0728" />
    </label>
    <button id="loadBtn">불러오기</button>

    <p id="status"></p>

    <!-- ✅ 오늘의 단어 섹션 -->
    <section id="dueSection" style="display:none; margin-top:24px;">
      <h2 style="margin:0 0 10px;">오늘의 단어</h2>
      <p style="margin:0 0 12px; opacity:.7; font-size:14px;">
        (이전에 ‘몰라요’를 눌러 3일 뒤 복습 대상으로 올라온 단어)
      </p>
      <div id="dueList"></div>
      <hr style="margin:18px 0; opacity:.3;" />
    </section>

    <!-- 기존 컨트롤 -->
    <div id="controls" style="display:none; margin-top:20px;">
      <label>
        세트 선택
        <select id="setSelect"></select>
      </label>
    </div>

    <div id="wordList" style="margin-top:20px;"></div>
  </div>

  <script>
    // ✅ Cloudflare Worker API
    const API_BASE = "https://vocab-check-api.amatda-team.workers.dev";

    const input = document.getElementById("studentIdInput");
    const button = document.getElementById("loadBtn");
    const status = document.getElementById("status");

    const controls = document.getElementById("controls");
    const setSelect = document.getElementById("setSelect");
    const wordList = document.getElementById("wordList");

    const dueSection = document.getElementById("dueSection");
    const dueList = document.getElementById("dueList");

    let currentIndex = null;
    let currentStudentId = "";
    let currentSetId = "";

    // ---------- helpers ----------
    function normalizeStudentId(raw) {
      return raw.trim().toLowerCase();
    }

    function maskText() {
      return "•••••";
    }

    function el(tag, props = {}, children = []) {
      const node = document.createElement(tag);
      Object.entries(props).forEach(([k, v]) => {
        if (k === "style") Object.assign(node.style, v);
        else if (k.startsWith("on") && typeof v === "function") node.addEventListener(k.slice(2).toLowerCase(), v);
        else if (k === "className") node.className = v;
        else node.setAttribute(k, v);
      });
      children.forEach((c) => node.appendChild(typeof c === "string" ? document.createTextNode(c) : c));
      return node;
    }

    async function apiPostEvent({ studentId, setId, word, meaning, result }) {
      const res = await fetch(`${API_BASE}/event`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ studentId, setId, word, meaning, result }),
      });
      if (!res.ok) throw new Error(`event 저장 실패: ${res.status}`);
      return res.json();
    }

    async function apiGetDue(studentId) {
      const res = await fetch(`${API_BASE}/due?studentId=${encodeURIComponent(studentId)}`, { cache: "no-store" });
      if (!res.ok) throw new Error(`due 로드 실패: ${res.status}`);
      return res.json();
    }

    // ---------- github pages data ----------
    async function loadStudentIndex(studentIdRaw) {
      const id = normalizeStudentId(studentIdRaw);
      const prefix = id.slice(0, 2);
      const indexPath = `data/students/${prefix}/${id}/index.json`;

      status.textContent = `불러오는 중... (${indexPath})`;

      const res = await fetch(indexPath, { cache: "no-store" });
      if (!res.ok) throw new Error(`index.json 로드 실패: ${res.status}`);

      const data = await res.json();
      if (!Array.isArray(data.sets)) throw new Error("index.json 형식 오류");

      return data;
    }

    async function loadSet(path) {
      const res = await fetch(path, { cache: "no-store" });
      if (!res.ok) throw new Error(`세트 로드 실패: ${res.status}`);
      return res.json();
    }

    function renderSetOptions(sets) {
      setSelect.innerHTML = "";
      sets.forEach((set) => {
        const opt = document.createElement("option");
        opt.value = set.path;
        opt.textContent = set.label || set.yyMMdd || set.date || set.path;
        setSelect.appendChild(opt);
      });
    }

    // ---------- UI render: Due ----------
    function renderDueWords(words) {
      dueList.innerHTML = "";

      if (!words || words.length === 0) {
        dueList.appendChild(
          el("div", { style: { opacity: ".7", fontSize: "14px" } }, ["오늘 복습할 단어가 없어요 ✅"])
        );
        return;
      }

      words.forEach((row) => {
        const { word, meaning, set_id } = row;

        const enEl = el("div", { style: { width: "160px", fontWeight: "700" } }, [word]);
        const koEl = el("div", { style: { flex: "1", cursor: "default" } }, [maskText()]);
        const metaEl = el("div", { style: { opacity: ".55", fontSize: "12px", width: "90px", textAlign: "right" } }, [
          set_id ? `#${set_id}` : "",
        ]);

        let revealed = false;
        const revealMeaning = () => {
          revealed = true;
          koEl.textContent = meaning || "";
        };

        const knowBtn = el(
          "button",
          {
            style: { padding: "6px 10px", cursor: "pointer" },
            onclick: async () => {
              try {
                revealMeaning();
                await apiPostEvent({
                  studentId: currentStudentId,
                  setId: set_id || null,
                  word,
                  meaning: meaning || "",
                  result: "know",
                });
                // know는 due에서 빠지게 하는 게 맞으니 즉시 재조회
                await refreshDue();
              } catch (e) {
                console.error(e);
                status.textContent = `❌ 저장 실패(알아요): ${e.message}`;
              }
            },
          },
          ["알아요"]
        );

        const dontBtn = el(
          "button",
          {
            style: { padding: "6px 10px", cursor: "pointer" },
            onclick: async () => {
              try {
                revealMeaning();
                await apiPostEvent({
                  studentId: currentStudentId,
                  setId: set_id || null,
                  word,
                  meaning: meaning || "",
                  result: "dontknow",
                });
                // dontknow는 3일 뒤 다시 나오게 설정되지만,
                // 지금 당장은 "다음 대상"만 반영되도록 due 재조회
                await refreshDue();
              } catch (e) {
                console.error(e);
                status.textContent = `❌ 저장 실패(몰라요): ${e.message}`;
              }
            },
          },
          ["몰라요"]
        );

        const btnWrap = el("div", { style: { display: "flex", gap: "8px" } }, [knowBtn, dontBtn]);

        const rowEl = el(
          "div",
          {
            style: {
              display: "flex",
              gap: "14px",
              alignItems: "center",
              marginBottom: "10px",
              padding: "10px 12px",
              border: "1px solid rgba(0,0,0,.12)",
              borderRadius: "10px",
            },
          },
          [enEl, koEl, metaEl, btnWrap]
        );

        dueList.appendChild(rowEl);
      });
    }

    async function refreshDue() {
      if (!currentStudentId) return;
      const data = await apiGetDue(currentStudentId);
      dueSection.style.display = "block";
      renderDueWords(data.words || []);
    }

    // ---------- UI render: Set words ----------
    function renderWords(words, setIdForEvent) {
      wordList.innerHTML = "";

      if (!words || words.length === 0) {
        wordList.appendChild(el("div", { style: { opacity: ".7" } }, ["단어가 없어요."]));
        return;
      }

      words.forEach(({ en, ko }) => {
        const enEl = el("div", { style: { width: "160px", fontWeight: "700" } }, [en]);
        const koEl = el("div", { style: { flex: "1" } }, [maskText()]);

        let revealed = false;
        const revealMeaning = () => {
          revealed = true;
          koEl.textContent = ko || "";
        };

        const knowBtn = el(
          "button",
          {
            style: { padding: "6px 10px", cursor: "pointer" },
            onclick: async () => {
              try {
                revealMeaning(); // ✅ 버튼 클릭하면 마스킹 해제
                await apiPostEvent({
                  studentId: currentStudentId,
                  setId: setIdForEvent,
                  word: en,
                  meaning: ko || "",
                  result: "know",
                });
                // 세트 학습 중에도 due는 갱신해주면 “오늘의 단어”가 바로 정리됨
                await refreshDue();
              } catch (e) {
                console.error(e);
                status.textContent = `❌ 저장 실패(알아요): ${e.message}`;
              }
            },
          },
          ["알아요"]
        );

        const dontBtn = el(
          "button",
          {
            style: { padding: "6px 10px", cursor: "pointer" },
            onclick: async () => {
              try {
                revealMeaning(); // ✅ 버튼 클릭하면 마스킹 해제
                await apiPostEvent({
                  studentId: currentStudentId,
                  setId: setIdForEvent,
                  word: en,
                  meaning: ko || "",
                  result: "dontknow",
                });
                await refreshDue();
              } catch (e) {
                console.error(e);
                status.textContent = `❌ 저장 실패(몰라요): ${e.message}`;
              }
            },
          },
          ["몰라요"]
        );

        const btnWrap = el("div", { style: { display: "flex", gap: "8px" } }, [knowBtn, dontBtn]);

        const row = el(
          "div",
          {
            style: {
              display: "flex",
              gap: "14px",
              alignItems: "center",
              marginBottom: "10px",
              padding: "10px 12px",
              border: "1px solid rgba(0,0,0,.12)",
              borderRadius: "10px",
            },
          },
          [enEl, koEl, btnWrap]
        );

        wordList.appendChild(row);
      });
    }

    // ---------- load flow ----------
    async function loadAll(studentIdRaw) {
      const raw = studentIdRaw;
      if (!raw.trim()) {
        status.textContent = "ID를 입력하세요.";
        return;
      }

      try {
        currentStudentId = normalizeStudentId(raw);
        currentIndex = await loadStudentIndex(currentStudentId);

        status.textContent = `✅ 세트 ${currentIndex.sets.length}개 로드됨`;
        controls.style.display = "block";

        renderSetOptions(currentIndex.sets);

        // 첫 세트 자동 로드
        const first = currentIndex.sets[0];
        const firstPath = first.path;
        currentSetId = first.yyMMdd || first.label || "";
        const words = await loadSet(firstPath);
        renderWords(words, first.yyMMdd || null);

        // ✅ due도 같이 로드
        await refreshDue();
      } catch (err) {
        console.error(err);
        status.textContent = `❌ 실패: ${err.message}`;
      }
    }

    // 버튼 클릭 로드
    button.addEventListener("click", async () => {
      await loadAll(input.value);
    });

    // ✅ 엔터로 로드
    input.addEventListener("keydown", async (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        await loadAll(input.value);
      }
    });

    // 세트 변경
    setSelect.addEventListener("change", async () => {
      try {
        const path = setSelect.value;
        const selected = (currentIndex?.sets || []).find((s) => s.path === path);
        const words = await loadSet(path);

        // selected.yyMMdd가 우리가 set_id로 쓰는 값(예: 260104)
        renderWords(words, selected?.yyMMdd || null);
      } catch (err) {
        console.error(err);
        status.textContent = `❌ 세트 변경 실패`;
      }
    });
  </script>
</body>
